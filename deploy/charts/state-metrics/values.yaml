# Global configuration
image: ghcr.io/labring/state-metrics:latest
imagePullPolicy: IfNotPresent
imagePullSecrets: []

nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

rbac:
  create: true

service:
  type: ClusterIP
  port: 9090
  targetPort: 9090
  annotations: {}

# TLS configuration for metrics endpoint
tls:
  enabled: true
  # Certificate duration (default: 90 days)
  duration: 2160h
  # Renew certificate before expiration (default: 30 days)
  renewBefore: 720h
  # Organization name in certificate
  organization: "sealos"
  # Name of existing cert-manager Issuer or ClusterIssuer
  # If not specified, a self-signed Issuer will be created
  issuer: ""
  # Kind of issuer (Issuer or ClusterIssuer)
  issuerKind: "Issuer"
  # Skip TLS verification in ServiceMonitor/VMServiceScrape (not recommended for production)
  insecureSkipVerify: false

# Authentication configuration for metrics endpoint
auth:
  enabled: true
  # List of ServiceAccounts allowed to access metrics
  # When auth is enabled, only these ServiceAccounts can scrape metrics
  allowedServiceAccounts:
    # Prometheus Operator default ServiceAccount
    - name: prometheus
      namespace: monitoring
    # Prometheus Operator kube-prometheus-stack default
    - name: prometheus-kube-prometheus-prometheus
      namespace: monitoring
    # VictoriaMetrics Operator k8s-stack (vm namespace)
    - name: vmagent-victoria-metrics-k8s-stack
      namespace: vm
    - name: vmalert-victoria-metrics-k8s-stack
      namespace: vm
    - name: vmcluster-victoria-metrics-k8s-stack
      namespace: vm
    - name: victoria-metrics-k8s-stack
      namespace: vm
    # Add custom ServiceAccounts below
    # - name: custom-prometheus
    #   namespace: custom-namespace

serviceMonitor:
  enabled: false
  namespace: ""
  labels: {}
  interval: 30s
  scrapeTimeout: 10s
  metricRelabelings: []
  relabelings: []

vmServiceScrape:
  enabled: false
  namespace: ""
  labels: {}
  interval: 30s
  scrapeTimeout: 10s
  metricRelabelConfigs: []
  relabelConfigs: []

# Application configuration
config:
  server:
    address: ":9090"
    metricsPath: "/metrics"
    healthPath: "/health"

  # Debug server configuration (hot-reloadable, no authentication)
  debugServer:
    enabled: true
    address: ":8080"
    metricsPath: "/metrics"
    healthPath: "/health"

  # Pprof configuration (hot-reloadable, binds to 127.0.0.1 only)
  pprof:
    enabled: false
    port: 6060

  kubernetes:
    kubeconfig: ""
    qps: 50
    burst: 100

  metrics:
    namespace: ""

  logging:
    level: "info"
    format: "json"
    debug: false

  performance:
    informerResyncPeriod: "10m"

# Leader election configuration
leaderElection:
  enabled: true
  leaseName: "state-metrics"
  leaseDuration: "15s"
  renewDeadline: "10s"
  retryPeriod: "2s"

# Enabled collectors
# Examples: [domain, node, imagepull, zombie, cloudbalance, lvm]
enabledCollectors:
  - lvm

# Instance identity (optional, defaults to NODE_NAME > POD_NAME > auto-detected)
identity: ""

# Collectors configuration
collectors:
  domain:
    domains: []
    checkTimeout: "5s"
    checkInterval: "5m"
    includeCertCheck: true
    includeHTTPCheck: true

  node: {}

  imagepull:
    slowPullThreshold: "5m"

  zombie:
    checkInterval: "30s"

  cloudbalance:
    checkInterval: "5m"
    accounts: []

  lvm:
    updateInterval: "10s"

# Pod configuration
podAnnotations: {}
podSecurityContext: {}
securityContext:
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 65532

resources:
  limits:
    cpu: 500m
    memory: 256Mi
  requests:
    cpu: 50m
    memory: 64Mi

livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 15
  periodSeconds: 20
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

nodeSelector: {}
tolerations:
  - operator: Exists
affinity: {}
priorityClassName: ""
