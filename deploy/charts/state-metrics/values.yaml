# Global configuration
image: ghcr.io/labring/state-metrics:latest
imagePullPolicy: IfNotPresent
imagePullSecrets: []

nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

rbac:
  create: true

service:
  type: ClusterIP
  port: 9090
  targetPort: 9090
  annotations: {}

serviceMonitor:
  enabled: false
  namespace: ""
  labels: {}
  interval: 30s
  scrapeTimeout: 10s
  metricRelabelings: []
  relabelings: []

vmServiceScrape:
  enabled: false
  namespace: ""
  labels: {}
  interval: 30s
  scrapeTimeout: 10s
  metricRelabelConfigs: []
  relabelConfigs: []

# Common application configuration (shared by both Deployment and DaemonSet)
config:
  server:
    address: ":9090"
    metricsPath: "/metrics"
    healthPath: "/health"

  kubernetes:
    kubeconfig: ""
    qps: 50
    burst: 100

  metrics:
    namespace: ""

  logging:
    level: "info"
    format: "json"
    debug: false

  performance:
    informerResyncPeriod: "10m"

# Deployment configuration (for collectors requiring leader election)
deploymentConfig:
  replicaCount: 1

  # Leader election configuration (Deployment only)
  leaderElection:
    enabled: true
    namespace: ""
    leaseName: "state-metrics"
    leaseDuration: "15s"
    renewDeadline: "10s"
    retryPeriod: "2s"

  # Collectors configuration
  enabledCollectors:
    - domain
    - node

  identity: ""

  collectors:
    domain:
      domains: []
      checkTimeout: "5s"
      checkInterval: "5m"
      includeCertCheck: true
      includeHTTPCheck: true

    node: {}

    pod:
      restartThreshold: 5

    imagepull:
      slowPullThreshold: "5m"

    zombie:
      checkInterval: "30s"

    cloudbalance:
      checkInterval: "5m"
      accounts: []

  # Pod configuration
  podAnnotations: {}
  podSecurityContext: {}
  securityContext:
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 65532

  resources:
    limits:
      cpu: 1000m
      memory: 512Mi
    requests:
      cpu: 100m
      memory: 128Mi

  livenessProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 15
    periodSeconds: 20
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  nodeSelector: {}
  tolerations: []
  affinity: {}
  priorityClassName: ""

# DaemonSet configuration (for node-level collectors like LVM)
daemonsetConfig:
  # Collectors configuration
  # Set enabledCollectors to enable DaemonSet deployment (e.g., [lvm])
  enabledCollectors: []

  identity: ""

  collectors:
    lvm:
      updateInterval: "10s"

  # Pod configuration
  podAnnotations: {}
  podSecurityContext: {}
  securityContext:
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 65532

  resources:
    limits:
      cpu: 500m
      memory: 256Mi
    requests:
      cpu: 50m
      memory: 64Mi

  livenessProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 15
    periodSeconds: 20
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  nodeSelector: {}
  tolerations:
    - operator: Exists
  affinity: {}
  priorityClassName: ""
